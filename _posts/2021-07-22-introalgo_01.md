---
title: "introduction to algorithms 01강"
excerpt: ""

categories:
    - algorithms
tags:
    - algorithms
    - daily
    - python
use_math: true
---

교재 : introduction to algorithms
강의 : [링크](https://youtu.be/JPyuH4qXLZ0)

[알고리즘 분석과 디자인](#알고리즘의 분석과 디자인)    
[삽입정렬](#삽입정렬)    
[복잡도](#복잡도)    

# 알고리즘의 분석과 디자인
* * *

### 성능    
*알고리즘 분석*은 *컴퓨터 프로그램 성능과 리소스 사용에 대한 이론적인 학문*이다. 분석하면서 많은 기술들을 익혀야 하며 어떤 알고리즘이 application들을 가장 빠르고 리소스 사용을 최적으로 할지 고민하여 나온 것이 디자인이다. 이렇게 우린 알고리즘을 분석하고 효율적으로 디자인을 하는데 있어 *성능*에 초점을 맞춘다.

### What’s more important than performance?
프로그래머의 입장이라면...    
• 프로그래머의 시간<sup>programmer time</sup> : 프로그래밍할 때 프로그래머의 시간
• 모듈방식<sup>modularity</sup>    
• 유지<sup>maintainability</sup>    

사용자의 입장이라면...    
• 사용하기 쉬움<sup>user-friendliness</sup> : 정량적인 기준은 없다.  
• 확장성<sup>extensibility, scalability</sup>
• 보안<sup>security</sup>   
• 정확성<sup>correctness</sup>    
• 간단함<sup>simplicity</sup>    
• 기능성<sup>functionality</sup>    

하지만 이 모든것들과 연결하여 설명할 수 있는 것이 **성능**이다.

### Why is performance important?(=Why study algorithm performance?)
1. 실시간 요구<sup>real-time requirements</sup>가 있을 때, 성능은 그것이 실현 가능한지 않은지를 구분해준다.    
    한번도 해본적 없는 일에 대해 알고리즘으로 그 일이 가능한지 불가능한지 말해줄 수 있다. 불가능하다면 시간이 너무 오래 걸려서(시간 복잡도) 안될 것 같다 라는 의견이나 다른 의견들이 제시될 수 있겠다.
2. 알고리즘이 프로그램이 어떻게 움직이는지에 대해 말해주는 언어이기 때문이다.   
    알고리즘은 컴퓨터 과학 전반에 걸쳐 사용되는 전문적인 언어이고 이론적인 언어이다. 왜냐하면 알고리즘은 프로그램의 움직임을 깔끔하게 이해하는 방법이며 성능을 이해하는 좋은 방법이다.
3. 돈과 연관되어 있다.    
    우리는 성능에 돈의 가치(비용)를 부여한다. 고사양의 노트북을 비싸지만 구매하는 이유이다.(물론 단순한 사치품과는 다르다.) 높은 성능의 제품은 비싼 돈의 가치가 있다고 보편적으로 판단된다. 우리가 쉽게 수량화할 수 있는 것이기 때문이다.
4.  it's tons of fun!    
    지극히 교수님 피셜이다. 알고리즘으로 높은 성능을 구현하면 빠르기 때문이다. 우리는 빠른것을 좋아한다. 8282      



# 정렬<sup>Sorting</sup>  
알고리즘의 기본적인 단계이다.
- - -
### 삽입정렬<sup>insertion sorting</sup>  
- 수행시간: 입력 크기 n값에 의해 결정된다.
- 입력 수열에 대해서도 어느 정도 정렬되어 있느냐에 따라서 수행시간이 달라진다.
- 수행시간(최악의 경우<sup>upper bound</sup>): $\theta \left( n^2 \right)$
### 의사코드<sup>pseudocode</sup>   

{% pseudocode %}
Insert-sort(A,n) -> A[1,...,n]    
  for j <- 2 to A.length    
  Do key <- A[j]    
    i <- j-1    
    While i>0 and A[i]>key    
    Do A[i+1] <- A[i]    
      i <- i-1    
    A[i+1] = key    
{% endpseudocode %}
```
insert-sort(A,n) -> A[1,...,n]    
    for j<-2 to n    
        do key<-A[j]    
           i<-j-1    
           while i>0 and A[i] > key   
           do A[i+1] <- A[i]    
              i<-i-1    
           A[i+1] = key    
```
### 병합정렬<sup>Merge sorting</sup>


# 복잡도
- - -
### 알고리즘의 분석 방법    
***최대시간*** : 어떠한 입력 사이즈에 대한 최대시간.    
    알고리즘의 러닝 타임에서 상한값<sup>upper bound</sup>. 이 이상의 시간은 걸리지 않는다는 것을 보장하기 위해 알고자 한다. 이는 한 알고리즘의 입력값n에 대한 함수이다. 하나밖에 없기 때문이다.     
***T(n)*** : 사이즈가 n인 입력 전반적으로 기대되는 시간.    
    기대되는 시간은 하나의 입력 값을 넣었을 때의 시간 / 모든 입력 값을 넣었을 때의 시간이다.

### 점근적 분석 방법<sup>Asymtotic Notation<sup>    
***세타 표기법*** : 3n^3 = 90n^2 - 5n + 6046 에서 낮은 차수의 항, 최고차 항으로 만든다. θ(n^3)    
***빅오 표기법*** :    
***오메가 표기법*** :    
